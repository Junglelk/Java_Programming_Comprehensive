# 集合和映射表

## 引言

集合*set*是用于存储和处理无重复元素的高效的数据结构。
映射表*map*类似于目录，提供了使用键值快速查询和获取值的功能。
注意：Java合集框架中的所有具体类，都至少有两个构造方法：

1. 创建空合集的无参构造方法；
2. 用某个合集来创建实例的方法。

## 集合

>有三个具体类*HashSet*、*LinkedHashSet*、*TreeSet*

### *HashSet*

最基本最典型的集合。可以使用它的无参构造方法创建一个默认的、空的散列集*hash set*，也可以由一个已有的***合集***创建散列集。
默认情况下，初始容量为16而负载系数为0.75 。*负载系数*是指集合容纳多少元素而不直接翻倍的指标。例如16个位置的集合，负载系数为0.75，
则当其存第12个元素时，容量自动倍增为32。

```java
import java.util.*;
public class TestHashSet {

    public static void main(String[] args) {

        Set<String> set = new HashSet<>();  
        set.add("London");
        set.add("Paris");
        set.add("New York");
        set.add("San Francisco");
        set.add("Beijing");
        set.add("Shanghai");
        set.add("Shanghai");

        System.out.println(set);

        for(String s:set) {
            System.out.print(s.toUpperCase()+"  ");
        }
    }

}
输出为：
[San Francisco, Beijing, New York, Shanghai, London, Paris]
SAN FRANCISCO  BEIJING  NEW YORK  SHANGHAI  LONDON、PARIS  

```

可见重复字符Shanghai未计入，且*输入顺序与输出顺序不符*；若需要记录输入顺序，则应使用***LinkedHashSet***。
此外，Collection接口继承Iterable接口，所以集合是可遍历的。又由于集合是Collection的一个实例，所以合集中的方法也可以用在集合上。

### *LinkedHashSet*

LinkedHashSet使用一个链表来扩展HashSet类，它支持对集合内的元素按输入顺序排序。如果使用一个HashSet作为参数生成LinkedHashSet，则会根据
原本HashSet内的存储位置的前后决定先后顺序，而非事实上的输入顺序(这应当是很显然的，毕竟HashSet不存在存储顺序的结构。)

```java
import java.util.*;
public class TestLinkedHashSet {

    public static void main(String[] args) {
        Set<String> set = new LinkedHashSet<String>();

        set.add("Nanjing");
        set.add("Beijing");
        set.add("Shanghai");
        set.add("Xuzhou");
        set.add("Beijing");

        System.out.println(set);

        for (String string : set) {
            System.out.print(string.toUpperCase() + "  ");
        }
    }
}
```

LinkedHashSet仅保存了输入顺序，若要强加别的顺序，可以使用TreeSet。

### *TreeSet*

SortedSet接口：

* first()
  * 返回集合中的第一个元素
* last()
  * 返回集合中的最后一个元素
* headSet(toElement)
  * 返回集合中小于toElement的元素
* tailSet(fromElement)
  * 返回集合中大于等于toElement的元素

NavigableSet扩展了SortedSet，提供方法：

* lower(e)
  * 返回小于e的元素
* floor(e)
  * 返回小于等于e的元素
* ceiling(e)
  * 返回大于等于e的元素
* higher(e)
  * 返回大于一个给定元素e的元素
* 若无相关元素，返回null

树形集合演示

```java
import java.util.*;

public class TestTreeSet {

    public static void main(String[] args) {
        LinkedHashSet<String> set = new LinkedHashSet<String>();

        set.add("London");
        set.add("Paris");
        set.add("Shanghai");
        set.add("New York");
        set.add("San Francisco");
        set.add("Beijing");
        set.add("Shanghai");
        System.out.println(set);
        TreeSet<String> treeSet = new TreeSet<String>(set);

        System.out.println("TreeSet内存储数据为："+treeSet);

        System.out.println("first():"+treeSet.first());                             //返回集合第一个字符
        System.out.println("last():"+treeSet.last());                               //返回集合最后一个字符
        System.out.println("headSet(\"New York\"):"+treeSet.headSet("New York"));   //返回New York之前的字符
        System.out.println("tailSet(\"New York\"):"+treeSet.tailSet("New York"));   //返回New York之后的字符
        System.out.println("lower(\"P\"): " + treeSet.lower("P"));                  //返回小于P的最大元素
        System.out.println("higher(\"P\"): " + treeSet.higher("P"));                //返回大于P的最小元素
        System.out.println("floor(\"P\"): " + treeSet.floor("P"));                  //返回小于等于P的最大元素
        System.out.println("ceiling(\"P\"): " + treeSet.ceiling("P"));              //返回大于等于P的最小元素
        System.out.println("pollFirst(): " + treeSet.pollFirst());                  //返回并删除头元素
        System.out.println("pollLast(): " + treeSet.pollLast());                    //返回并删除尾元素
        System.out.println("New tree set: " + treeSet);                             //打印删除元素后的新集合
    }

}
```

如果使用无参构造方法创建一个TreeSet，则会假定元素的类实现了Comparable接口并实现了compareTo()方法，并使用compareTo方法来比较集合中的元素。要使用comparator，则必须用构造方法TreeSet(Comparator comparator)，使用比较器中的compare方法创建一个排好序的集合(不明白怎么排序的)。解释如何排序：TreeSet底层是TreeMap，而TreeMap用红黑树来排序，根据可比较文件的compareTo()方法进行比较并插入二叉树中，可以实现极快的存取速度。

#### 示例学习：统计关键字数

稍加修改应该可以做到输出各个关键字数，但我目前想到的方法有点类似于穷举法，略显无聊，且工作量巨大；

```java
import java.util.*;
import java.io.*;

public class CountKeywords {

  public static void main(String[] args) throws Exception {
    Scanner input = new Scanner(System.in);
    /*
     * 从键盘读取输入
     * 以键盘输入的文件路径创建寄生文件类实例
     * 将寄生文件实例传给计数方法
     * 计数方法接受一个寄生文件实例
     * 创建一个关键字集合
     * 以寄生文件实例做输入
     * 在仍有输入的情况下循环计数，判断条件为contains(words)
     * 两个方法都需要抛出异常
     */
    System.out.println("输入文件目录");
    File file = new File(input.nextLine());
    input.close();
    if(file.exists()) {
      System.out.println("文件内关键字个数为："+countKeywords(file));
    }
    else System.out.println("文件不存在");
}

  public static int countKeywords(File file) throws Exception {
    String[] keywordString = {"abstract", "assert", "boolean",
            "break", "byte", "case", "catch", "char", "class", "const",
            "continue", "default", "do", "double", "else", "enum",
            "extends", "for", "final", "finally", "float", "goto",
            "if", "implements", "import", "instanceof", "int",
            "interface", "long", "native", "new", "package", "private",
            "protected", "public", "return", "short", "static",
            "strictfp", "super", "switch", "synchronized", "this",
            "throw", "throws", "transient", "try", "void", "volatile",
            "while", "true", "false", "null"};
    /*
     * Set<String> keySet = new HashSet<String>(keywordString);
     * 这个写法是错误的
     * 因为keywordString本身是字符串数组，不是泛型实例
     * 应当用Array转换才行
     */

    Set<String> keySet = new HashSet<String>(Arrays.asList(keywordString));
    int count = 0;
    Scanner input = new Scanner(file);
    while(input.hasNext()) {
      String word = input.next();
      if(keySet.contains(word)) {
        count++;
      }
    }
    input.close();
    return count;

}
```

## 映射表

>有三个具体类*HashMap*、*LinkedHashMap*、*TreeMap*

映射表(map)是一种按照键值对存储元素的容器。它提供通过键快速获取、删除和更新键值对的功能。键值对将键和值一起保存。键类似于下标，但在map中可以为任意类型值。

![键值对的模式](https://preview.cloud.189.cn/image/imageAction?param=C6A69523E9E8E91D7EB1A28374905FEC00B2F89B93FD4EF806301AA04FD2686FCCAF57991332F83B755E375043FDD3439E6619D6E69BB6FBD3AF88ABF2C2EA4070A48CAE8D2D257247DC3CEA89BFCAABD4910DCA627E34B00C2F61A7)

![映射表的继承关系](https://preview.cloud.189.cn/image/imageAction?param=427A5377B6FE7CDB3651835CE6C289CBE4105FC263F12B954C71CFCE7F4838E67FB71D3B30632FE41A6EEDCEDB3DBA621593E06C38A3856E56F1E4776ACCB878641491C23BB7F9D9C943A6EA66FBAF879645148B10AABA77CDA13B61)  

从左至右，分别为接口、抽象类、具体类

Map接口提供查询、更新和获取合集值和合集的键的方法
更新方法

* clear()删除所有映射表内所有的值;
* put(K key, V value)为映射表中指定的键和值添加条目;
* putAll(Map m)将m中的所有条目添加到这个映射表中;
* remove(Object key)将指定键对应的条目从映射表中删除。

查询方法

* containskey(Object key)检测映射表中是否包含指定键的条目;
* containsvalue(Object value)检测映射表中是否包含指定值的条目;
* isEmpty()检测映射表是否为空;
* size()返回映射表中条目中的个数。

![三个具体映射表类](https://preview.cloud.189.cn/image/imageAction?param=510E976EBBD23888873386379C74373A5C1FBC3ADDA0CE28F30ADCD8DCE64CDA2C5B5FD2882AA61EF4422AEA463295EDC18BA212D9B53D5F40F11AA93A828248B3646DC37E80DF7FC3FC196D78276F0B64CE0B4ED21BCB45FE5CF6FF "映射表类")

### 散列映射表*HashMap*

定位一个值、插入一个条目以及删除一个条目而言，HashMap是高效的。
HashMap中元素没有顺序。

### 链式散列映射表*LinkedHashMap*

使用链表拓展HashMap，它支持映射表中条目的排序。
在LinkedHashMap中，元素既可以按照插入顺序排序，也可以按照它们最后一次访问顺序排序，从早到晚排序。无参构造方法是默认插入顺序排序，要按访问顺序创建LinkedHashMap对象，应使用LinkedHashMap(initialCapacity,loadFactor, true)。

### 树形映射表*TreeMap*

TreeMap可以高效遍历排好序的键。键可以使用Comparable接口和Comparator接口排序。
无参构造方法创建一个TreeMap实例，假定键类已经实现Comparable接口，则可使用compareTo方法来对键进行比较。
若使用比较器则需要使用构造方法TreeMap(Comparator comparator)来创建有序映射表。

```java
import java.util.*;

public class TestMap {

  public static void main(String[] args) {

    Map<String, Integer> hashMap = new HashMap<String, Integer>();
    hashMap.put("张三", 23);
    hashMap.put("李四", 25);
    hashMap.put("王二", 27);
    hashMap.put("牛二", 38);
    hashMap.put("建国", 65);
    System.out.println(hashMap);
    Map<String, Integer> linkedHashMap = new LinkedHashMap<String, Integer>(16,0    75f,true);
    //此时创建的linkedHashMap是可按访问顺序排序 
    linkedHashMap.put("张三", 29);
    linkedHashMap.put("李四", 25);
    linkedHashMap.put("王二", 54);
    linkedHashMap.put("牛二", 38);
    linkedHashMap.put("建国", 65);
    System.out.println(linkedHashMap);
    /*
     * 按照输入顺序排序
     */
    System.out.println(linkedHashMap.get("王二"));//访问一个字段后，按访问顺序排序
    System.out.println(linkedHashMap);
    Map<String, Integer> treeMap = new TreeMap<String, Integer>();
    treeMap.put("a", 29);
    treeMap.put("c", 25);
    treeMap.put("e", 54);
    treeMap.put("d", 38);
    treeMap.put("b", 65);
    System.out.println(treeMap);//tree默认按键的升序排序
  }

}
```

### 其他

SortedMap是Map的一个子接口，使用它可以确保映射表中的条目是排好序的。此外也提供方法获取第一个、最后一个键，以及大于小于特定键的键。  
NavigableMap继承了SortedMap，提供返回小于lowerKey(key)、floorKey(key)小于等于、ceilingKey(key)大于、higherKey(key)大于等于某个特定键的键。

### 示例学习：统计单词出现次数

```java
import java.util.*;
public class CountOccurrenceOfWords {

  public static void main(String[] args) {
    String text = "O. Henry was a pen name used by an American writer of "
        + "short stories. His real name was William Sydney Porter. "
        + "He was born in North Carolina in 1862."
        + " As a young boy he lived an exciting life. "
        + "He did not go to school for very long, "
        + "but he managed to teach himself everything he needed to know. "
        + "When he was about 20 years old, O. Henry went to Texas, "
        + "where he tried different jobs. He first worked on a newspaper, "
        + "and then had a job in a bank, when some money went missing from the bank "
        + "O. Henry was believed to have stolen it. Because of that, "
        + "he was sent to prison. During the three years in prison, "
        + "he learned to write short stories. After he got out of prison, "
        + "he went to New York and continued writing. He wrote mostly about "
        + "New York and the life of the poor there. "
        + "People liked his stories, because simple as the tales were, "
        + "they would finish with a sudden change at the end, to the reader’s surprise.";
    Map<String, Integer> map = new TreeMap<String, Integer>();

    String[] word = text.split("[ \n\t\t.,;:!?(){}]");

    for (int i = 0; i < word.length; i++) {
      String key = word[i].toLowerCase();
      if(word.length>0) {
      if(!map.containsKey(key)) {
        map.put(key, 1);
        }
      else {
        int value = map.get(key);
        value++;
        map.put(key, value);
        }
      }
    }
    Set<Map.Entry<String, Integer>> entrySet = map.entrySet();

    for (Map.Entry<String, Integer> entry : entrySet) {
      System.out.println(entry.getKey()+"\t"+entry.getValue());
    }
  }
}
```

## 单元素与不可变的合集和映射表

|java.util.Collection|说明|
|-------|-------|
|+<u>singleton(o:Object):Set</u>|返回一个包含了指定对象的不可修改的集合|
|+<u>singletonList(o:Object):List</u>|返回一个包含了指定对象的不可修改的线性表|
|+<u>singletonMap(key:Object,value:Object):Map</u>|返回一个具有键值对的不可修改的映射表|
|+<u>unmodifiableCollection(c:Collection):Collection</u>|返回一个合集的只读视图|
|+<u>unmodifiableList(list:List):List</u>|返回一个线性表的只读视图|
|+<u>unmodifiableMap(m:Map):Map</u>|返回一个映射表的只读视图|
|+<u>unmodifiableSet(s:Set):Set</u>|返回一个集合的只读视图|
|+<u>unmodifiableSortedMap(s:SortedMap):SortedMap</u>|返回一个排好序的映射表的只读视图|
|+<u>unmodifiableSet(s:SortedSet):SortedSet</u>|返回一个排好序的集合的只读视图|
