# 集合和映射表

## 引言

集合*set*是用于存储和处理无重复元素的高效的数据结构。
映射表*map*类似于目录，提供了使用键值快速查询和获取值的功能。
注意：Java合集框架中的所有具体类，都至少有两个构造方法：

1. 创建空合集的无参构造方法；
2. 用某个合集来创建实例的方法。

## 集合

>有三个具体类*HashSet*、*LinkedHashSet*、*TreeSet*

### *HashSet*

最基本最典型的集合。可以使用它的无参构造方法创建一个默认的、空的散列集*hash set*，也可以由一个已有的***合集***创建散列集。
默认情况下，初始容量为16而负载系数为0.75 。*负载系数*是指集合容纳多少元素而不直接翻倍的指标。例如16个位置的集合，负载系数为0.75，
则当其存第12个元素时，容量自动倍增为32。

```java
import java.util.*;
public class TestHashSet {

    public static void main(String[] args) {

        Set<String> set = new HashSet<>();  
        set.add("London");
        set.add("Paris");
        set.add("New York");
        set.add("San Francisco");
        set.add("Beijing");
        set.add("Shanghai");
        set.add("Shanghai");

        System.out.println(set);

        for(String s:set) {
            System.out.print(s.toUpperCase()+"  ");
        }
    }

}
输出为：
[San Francisco, Beijing, New York, Shanghai, London, Paris]
SAN FRANCISCO  BEIJING  NEW YORK  SHANGHAI  LONDON、PARIS  

```

可见重复字符Shanghai未计入，且*输入顺序与输出顺序不符*；若需要记录输入顺序，则应使用***LinkedHashSet***。
此外，Collection接口继承Iterable接口，所以集合是可遍历的。又由于集合是Collection的一个实例，所以合集中的方法也可以用在集合上。

### *LinkedHashSet*

LinkedHashSet使用一个链表来扩展HashSet类，它支持对集合内的元素按输入顺序排序。如果使用一个HashSet作为参数生成LinkedHashSet，则会根据
原本HashSet内的存储位置的前后决定先后顺序，而非事实上的输入顺序(这应当是很显然的，毕竟HashSet不存在存储顺序的结构。)

```java
import java.util.*;
public class TestLinkedHashSet {

    public static void main(String[] args) {
        Set<String> set = new LinkedHashSet<String>();

        set.add("Nanjing");
        set.add("Beijing");
        set.add("Shanghai");
        set.add("Xuzhou");
        set.add("Beijing");

        System.out.println(set);

        for (String string : set) {
            System.out.print(string.toUpperCase() + "  ");
        }
    }
}
```

LinkedHashSet仅保存了输入顺序，若要强加别的顺序，可以使用TreeSet。

### *TreeSet*

SortedSet接口：

* first()
  * 返回集合中的第一个元素
* last()
  * 返回集合中的最后一个元素
* headSet(toElement)
  * 返回集合中小于toElement的元素
* tailSet(fromElement)
  * 返回集合中大于等于toElement的元素

NavigableSet扩展了SortedSet，提供方法：

* lower(e)
  * 返回小于e的元素
* floor(e)
  * 返回小于等于e的元素
* ceiling(e)
  * 返回大于等于e的元素
* higher(e)
  * 返回大于一个给定元素e的元素
* 若无相关元素，返回null

树形集合演示

```java
import java.util.*;

public class TestTreeSet {

    public static void main(String[] args) {
        LinkedHashSet<String> set = new LinkedHashSet<String>();

        set.add("London");
        set.add("Paris");
        set.add("Shanghai");
        set.add("New York");
        set.add("San Francisco");
        set.add("Beijing");
        set.add("Shanghai");
        System.out.println(set);
        TreeSet<String> treeSet = new TreeSet<String>(set);

        System.out.println("TreeSet内存储数据为："+treeSet);

        System.out.println("first():"+treeSet.first());                             //返回集合第一个字符
        System.out.println("last():"+treeSet.last());                               //返回集合最后一个字符
        System.out.println("headSet(\"New York\"):"+treeSet.headSet("New York"));   //返回New York之前的字符
        System.out.println("tailSet(\"New York\"):"+treeSet.tailSet("New York"));   //返回New York之后的字符
        System.out.println("lower(\"P\"): " + treeSet.lower("P"));                  //返回小于P的最大元素
        System.out.println("higher(\"P\"): " + treeSet.higher("P"));                //返回大于P的最小元素
        System.out.println("floor(\"P\"): " + treeSet.floor("P"));                  //返回小于等于P的最大元素
        System.out.println("ceiling(\"P\"): " + treeSet.ceiling("P"));              //返回大于等于P的最小元素
        System.out.println("pollFirst(): " + treeSet.pollFirst());                  //返回并删除头元素
        System.out.println("pollLast(): " + treeSet.pollLast());                    //返回并删除尾元素
        System.out.println("New tree set: " + treeSet);                             //打印删除元素后的新集合
    }

}
```

如果使用无参构造方法创建一个TreeSet，则会假定元素的类实现了Comparable接口并实现了compareTo()方法，并使用compareTo方法来比较集合中的元素。要使用comparator，则必须用构造方法TreeSet(Comparator comparator)，使用比较器中的compare方法创建一个排好序的集合(不明白怎么排序的)。解释如何排序：TreeSet底层是TreeMap，而TreeMap用红黑树来排序，根据可比较文件的compareTo()方法进行比较并插入二叉树中，可以实现极快的存取速度。

## 映射表

>有三个具体类*HashMap*、*LinkedHashMap*、*TreeMap*

### *HashMap*

### *LinkedHashMap*

### *TreeMap*
